class Node:
    """
    Stores node probability, children, and symbol (None if not a leaf)
    """
    def __init__(self, probability, symbol = None, left_child = None, right_child = None):
        self.prob = probability
        self.symbol = symbol
        self.left_child = left_child
        self.right_child = right_child


def merge(a, b):
    """ returns a new node with children a and b, and probability as the sum of each of probabilities of a and b
    assumes the mutual exclusivity of a and b """
    return Node(a.prob + b.prob, left_child = a, right_child = b)


def tree_mapping(root, prefix = ""):
    """ returns a dict of the form {symbol, binary encoding} from the tree beginning at root
        assumes proper huffman encoding """
    if root.left_child is None: # in a proper huffman encoding, nodes either have two children or zero
        return {root.symbol: prefix}
        
    return {**tree_mapping(root.left_child, prefix + "0"), **tree_mapping(root.right_child, prefix + "1")}


def code_map(symbols):
    """ returns a dict of the form {str symbol: str binary encoding} and the root node of the binary tree
        generated by huffman algorithm,
        input symbols: dict of the form {symbol, probability of occurrence}
    """
    nodes = []
    for symbol, prob in symbols.items():
        nodes.append(Node(prob, symbol))

    # terminate if no nodes to start with
    if len(nodes) == 0:
        return []

    def get_prob(node):
        return node.prob

    while len(nodes) > 1:
        nodes.sort(key=get_prob)
        # remove the two smallest probability nodes from the nodes list
        a = nodes.pop(0)
        b = nodes.pop(0)
        nodes.append(merge(a, b))

    # the last node that was a merging (now nodes[0]) forms the tree root
    return tree_mapping(nodes[0]), nodes[0]


def encode(text, code, code_symbol_seq_len=1):
    """ Returns a binary string encoding sequence with the mapping provided by code
        If huffman code is optimized by mapping sequences of symbols to encodings, use code_symbol_seq_len to specify
        the number of symbols per mapping pair
        text: iterable, where each element is a single symbol
        (assumes each symbol is a string, but does not assume its length)
    """
    encoding = []
    current_seq = []
    for symbol in text:
        current_seq.append(symbol)
        if len(current_seq) == code_symbol_seq_len:
            encoding.append(code["".join(current_seq)])
            current_seq = []

    return "".join(encoding)


def decode(encoding, root):
    """ :return list of symbols (or symbol sequences)
        using the root node of the binary tree generated from huffman encoding"""
    text = []
    current_node = root
    for bit in encoding:
        if bit == "0":
            current_node = current_node.left_child
        elif bit == "1":
            current_node = current_node.right_child

        if current_node.symbol is not None:
            text.append(current_node.symbol)
            current_node = root

    return text


if __name__ == "__main__":
    # test-case symbols is the probability distribution for the sum of two dice rolls
    '''symbols = {"2": 1/36,
               "3": 2/36,
               "4": 3/36,
               "5": 4/36,
               "6": 5/36,
               "7": 6/36,
               "8": 5/36,
               "9": 4/36,
               "10": 3/36,
               "11": 2/36,
               "12": 1/36
               }'''

    code, root = code_map(symbols)
    print("Huffman encoding:")
    s = 0
    for symbol, encoding in code.items():
        print(f"{symbol} : {encoding}")
        s += symbols[symbol]*len(encoding) # length of encoding times probability of occurring
    print(f"expected binary digits per character transmitted: {s}\n")

    encoded = encode(["3", "6", "10"], code)
    print(encoded)
    decoded = decode(encoded, root)
    print(decoded)





    
